<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>WebGL Moving Points with Proximity Lines</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
      background-color: #eee;
    }
  </style>
</head>

<body>
  <canvas id="glcanvas"></canvas>

  <script type="text/javascript">
    const canvas = document.getElementById("glcanvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const gl = canvas.getContext("webgl");

    if (!gl) {
      alert("WebGL not supported");
    }

    // Vertex shader for points and lines
    const vertexShaderSrc = `
  attribute vec3 a_position;
  uniform vec2 u_resolution;
  varying float v_brightness;
  void main() {
    vec2 zeroToOne = vec2(a_position.x,a_position.y) / u_resolution;
    vec2 clipSpace = zeroToOne * 2.0 - 1.0;
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    gl_PointSize = 4.0;
    v_brightness = a_position.z;
  }
`;

    // Fragment shader for points and lines
    const fragmentShaderSrc = `
  precision mediump float;
  varying float v_brightness;
  uniform vec3 u_color;
  void main() {
    gl_FragColor = vec4(u_color, v_brightness);
  }
`;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);
    const program = createProgram(gl, vertexShader, fragmentShader);

    const posAttribLoc = gl.getAttribLocation(program, "a_position");
    const resUniformLoc = gl.getUniformLocation(program, "u_resolution");
    const colorUniformLoc = gl.getUniformLocation(program, "u_color");

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    const n = 350;
    const maxDistance = 90;
    const points = Array.from({ length: n }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 2.5,
      vy: (Math.random() - 0.5) * 1.5,
    }));
    let time = 0;

    function updatePositions() {
      time += 0.01; // Increment time for continuous motion

      for (let i = 0; i < points.length; i++) {
        let p = points[i];

        // More complex, still periodic movement with layered trigonometric functions
        let t = time + i;
        let xOffset = Math.cos(t) * p.vx + Math.sin(t * 0.5 + i * 0.3) * p.vx * 0.5;
        let yOffset = Math.sin(t) * p.vy + Math.cos(t * 0.7 + i * 0.2) * p.vy * 0.5;

        p.x += xOffset;
        p.y += yOffset;
      }
    }


    function drawScene() {
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.enableVertexAttribArray(posAttribLoc);
      gl.uniform2f(resUniformLoc, canvas.width, canvas.height);

      // Draw lines between close points
      const linePositions = [];
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          const dx = points[i].x - points[j].x;
          const dy = points[i].y - points[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const brightness = 1 - dist / maxDistance // Brightness based on distance
          if (dist < maxDistance) {
            linePositions.push(points[i].x, points[i].y, brightness);
            linePositions.push(points[j].x, points[j].y, brightness);
          }
        }
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(linePositions), gl.STATIC_DRAW);
      gl.vertexAttribPointer(posAttribLoc, 3, gl.FLOAT, false, 0, 0);
      gl.uniform3f(colorUniformLoc, 0.01, 0.01, 0.01);
      gl.drawArrays(gl.LINES, 0, linePositions.length / 3);

      // Draw points
      const pointPositions = [];
      for (let p of points) {
        pointPositions.push(p.x, p.y, 1);
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pointPositions), gl.STATIC_DRAW);
      gl.vertexAttribPointer(posAttribLoc, 3, gl.FLOAT, false, 0, 0);
      gl.uniform3f(colorUniformLoc, .01, .01, .01);
      gl.drawArrays(gl.POINTS, 0, n);
    }

    function render() {
      updatePositions();
      drawScene();
      requestAnimationFrame(render);
    }
    render();
  </script>
</body>

</html>